101
121 这两个和前面差不多, 可能
100
P1 (lambda () (set! x ((s (lambda () (* x x)))))) 
P2 (s (lambda () (set! x (+ x 1))))
重点是P1被拆开成两个逻辑单元了, 所以在这个中间P2能插进入执行
; 从而[P1先读了两次10, 然后计算10 * 10=100] =>  [P2读出10, 然后+ 10 1 = 11, 然后set x = 11]  =>   [P1设置100]
; 从而覆盖掉了P2的修改, 存在最后的值是100的可能性

110: 不可能, 因为不会出现一次读出10和一次读出11, P1的两次读和计算 整个被包裹起来了
11: 不可能出现P2覆盖掉P1的情况 